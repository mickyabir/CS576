load ../imp.maude

fmod LIST-EQUAL is
  pr IMP-LIST .
  op _andbool_ : Bool Bool -> Bool [comm assoc metadata "78"] .
  op _==list_  : List List -> Bool [comm metadata "79"] .

  var A : Bool .

  eq false andbool A = false .
  eq true andbool A = A .

  var L L' : List . var M N : Nat .

  eq nil ==list nil = true .
  eq (M $ L) ==list nil = false .
  eq (M $ L) ==list (N $ L') = (L ==list L') andbool (M <= N) andbool (N <= M) .
endfm

fmod REV is
  pr LIST-EQUAL .

  op rev : List -> List [metadata "80"] .

  var L : List . var N : Nat .

  eq rev(nil) = nil .
  eq rev(N $ L) = rev(L) $ N .
endfm

mod REV+IMP-SYNTAX+MUL is
  pr REV .
  pr IMP-SYNTAX+MUL .
endm

mod REV+IMP-SEMANTICS is
  pr REV .
  pr IMP-SEMANTICS .
endm

set show advisories off .
set print attribute on .

load ../ext/maude-private/contrib/tools/rltool/rltool.maude

(select REV+IMP-SEMANTICS  .)
(use tool conrew for validity          on REV+IMP-SYNTAX+MUL with FOFORMSIMPLIFY-IMP-IMPL .)
(use tool varunif for varunif          on FVP-NAT .)
(use tool varsat  for unsatisfiability on IMP-SYNTAX .)
(def-term-set (< done | E:Env >) | true .)
(declare-vars (X:List) U (X':List) U (Y:List) U (Y':List) U (Z:List) U (Z':List) .)

(add-goal loop : (<  while (! empty(x)) { y =l first(x) ++list y ; x =l last(x) ; } ~> done
                    | (x |-> TList * y |-> TList * z |-> TList)
                    & (x |-> X * y |-> Y * z |-> Z) >) | (Z) = (rev(Y) $ X) =>
                 (< done
                    | (x |-> TList * y |-> TList * z |-> TList)
                    & (x |-> X' * y |-> Y' * z |-> Z') >) | (Z') = (rev(Y')) /\ (Z) = (Z') .)


(start-proof .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)

quit .
