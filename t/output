		     \||||||||||||||||||/
		   --- Welcome to Maude ---
		     /||||||||||||||||||\
	   Maude alpha120 built: Dec  7 2018 20:37:50
	    Copyright 1997-2018 SRI International
		   Sat May  2 09:47:08 2020

	    Maude Reachability Logic Prover prototype -- Oct. 1st 2019

Set module to IMP-SEMANTICS
Command: select IMP-SEMANTICS .

Loaded function conrew for validity
Command: use tool conrew for validity on IMP-SYNTAX+MUL with
    FOFORMSIMPLIFY-IMP-IMPL .

Loaded function varunif for varunif
Command: use tool varunif for varunif on FVP-NAT .

Loaded function varsat for unsatisfiability
Command: use tool varsat for unsatisfiability on IMP-SYNTAX .

Added terminating state:
        < done | E:Env >  |||  true
Command: def-term-set(< done | E:Env >)| true .

Declared variable(s):
       { K:Continuation, X':List, X:List, Y':List, Y:List, Z:List }
Command: declare-vars(X:List)U(X':List)U(Y:List)U(Y':List)U(Z:List)U(
    K:Continuation).

Added goal(s):
       [migrate :  <(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})~> K:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x
    |-> X:List)*(y |-> Y:List)*(z |-> Z:List))>  |||  Z:List = Y:List $ X:List 
    =>  < K:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X':List)*(y |-> Y':List)*(z |-> Z:List))>  |||  Z:List = Y':List $ X':List
    /\ true = isEmpty(X':List)]
Command: add-goal migrate :(< while(! empty(x)){y =l y $: first(x); x =l rest(
    x);}~> K |(x |-> TList * y |-> TList * z |-> TList)&(x |-> X * y |-> Y * z
    |-> Z)>)|(Z)=(Y $ X)=>(< K |(x |-> TList * y |-> TList * z |-> TList)&(x
    |-> X' * y |-> Y' * z |-> Z)>)|(Z)=(Y' $ X')/\(isEmpty(X'))=(true).

Started proof:
       [1     |  <(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})~> K&27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x
    |-> X&28:List)*(y |-> Y&30:List)*(z |-> Z&32:List))>  |||  Z&32:List =
    Y&30:List $ X&28:List  =>  < K&27:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&29:List)*(y |-> Y&31:List)*(z |->
    Z&32:List))>  |||  Z&32:List = Y&31:List $ X&29:List /\ true = isEmpty(
    X&29:List)]
Command: start-proof .

Constraint: "Z&32:List = Y&30:List $ X&28:List"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
"step-action" step successors: 1
Constraint: "true"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Warning: goal  2  satisfaction unknown: conservatively retaining goal
Warning: goal  6  satisfaction unknown: conservatively retaining goal
Auto Results:
       [9     |  <(if((! empty(x))){((y =l(y $: first(x));)(x =l rest(x);))(
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  true  =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "true /\\ false = val? (! empty (x))"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  9
Warning: goal  12  satisfaction unknown: conservatively retaining goal
Auto Results:
       [15    |  <(! empty(x))~>((if([]){((y =l(y $: first(x));)(x =l rest(
    x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation)|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  true  =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "true /\\ false = val? (empty (x))"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  15
Warning: goal  18  satisfaction unknown: conservatively retaining goal
Auto Results:
       [21    |  < empty(x)~>(![]~>((if([]){((y =l(y $: first(x));)(x =l rest(
    x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  true  =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "true /\\ false = val? (x)"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  21
Warning: goal  24  satisfaction unknown: conservatively retaining goal
Auto Results:
       [27    |  < x ~>(empty([])~>(![]~>((if([]){((y =l(y $: first(x));)(x =l
    rest(x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})}else{})~> &27:Continuation)))|((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))> 
    |||  true  =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>
     |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $
    X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "true"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  27
Warning: goal  30  satisfaction unknown: conservatively retaining goal
Auto Results:
       [33    |  < &29:List ~>(empty([])~>(![]~>((if([]){((y =l(y $: first(
    x));)(x =l rest(x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})}else{})~> &27:Continuation)))|((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> &29:List)*(y |-> &28:List)*(z |->(&28:List $ &29:List)))> 
    |||  true  =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&28:List $ &29:List)))>
     |||  true = isEmpty(X&30:List)/\ &28:List $ &29:List = Y&31:List $
    X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "true"
"simp-action" step successors: 1
NOT UNSAT: tt
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  33
Warning: goal  36  satisfaction unknown: conservatively retaining goal
Auto Results:
       [39    |  < empty(&27:List)~>(![]~>((if([]){((y =l(y $: first(x));)(x =l
    rest(x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})}else{})~> &28:Continuation))|((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> &27:List)*(y |-> &29:List)*(z |->(&29:List $ &27:List)))> 
    |||  true  =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &27:List)))>
     |||  true = isEmpty(X&30:List)/\ &29:List $ &27:List = Y&31:List $
    X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 2
Constraint: "true /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "true /\\ &30:Bool = isEmpty (&27:List)"
"simp-action" step successors: 1
UNSAT: 'false.Bool ?= 'true.Bool
"sub-action" step successors: 0
NOT UNSAT: '&30:Bool ?= 'isEmpty['&27:List]
CR Simplification Round Reduced Implication to ff
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  39
Warning: goal  44  satisfaction unknown: conservatively retaining goal
Auto Results:
       [47    |  < &30:Bool ~>(![]~>((if([]){((y =l(y $: first(x));)(x =l rest(
    x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &28:Continuation))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &27:List)*(y |-> &29:List)*(z |->(&29:List $ &27:List)))>  |||  &30:Bool =
    isEmpty(&27:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $
    &27:List)))>  |||  true = isEmpty(X&31:List)/\ &29:List $ &27:List =
    Y&32:List $ X&31:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "&27:Bool = isEmpty (&29:List)"
"simp-action" step successors: 1
NOT UNSAT: '&27:Bool ?= 'isEmpty['&29:List]
CR Simplification Round Reduced Implication to ff
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  47
Warning: goal  50  satisfaction unknown: conservatively retaining goal
Auto Results:
       [53    |  <(! &27:Bool)~>((if([]){((y =l(y $: first(x));)(x =l rest(
    x);))(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &28:Continuation)|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &30:List)*(z |->(&30:List $ &29:List)))>  |||  &27:Bool =
    isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&30:List $
    &29:List)))>  |||  true = isEmpty(X&31:List)/\ &30:List $ &29:List =
    Y&32:List $ X&31:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 3
Constraint: "&27:Bool = isEmpty (&29:List) /\\ false = val? (&27:Bool)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:Bool]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "true = isEmpty (&28:List)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
UNSAT: '&27:Bool ?= 'isEmpty['&29:List] /\ 'false.Bool ?= 'true.Bool
"sub-action" step successors: 0
NOT UNSAT: 'true.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  53
Warning: goal  59  satisfaction unknown: conservatively retaining goal
Warning: goal  60  satisfaction unknown: conservatively retaining goal
Auto Results:
       [65    |  < false ~>((if([]){((y =l(y $: first(x));)(x =l rest(x);))(
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation)|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
       [66    |  < true ~>((if([]){((y =l(y $: first(x));)(x =l rest(x);))(
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation)|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  false =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
Action consumed 1 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "true = isEmpty (&28:List)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
NOT UNSAT: 'true.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  65
Notice: no syntactically usable instances of axiom migrate found for  66
Warning: goal  71  satisfaction unknown: conservatively retaining goal
Warning: goal  72  satisfaction unknown: conservatively retaining goal
Auto Results:
       [77    |  <(if(false){((y =l(y $: first(x));)(x =l rest(x);))(while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
       [78    |  <(if(true){((y =l(y $: first(x));)(x =l rest(x);))(while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})}else{})~>
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  false =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 2
Constraint: "true = isEmpty (&28:List)"
"simp-action" step successors: 1
Constraint: "false = val? (false) /\\ true = isEmpty (&28:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['false.Bool]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List) /\\ false = val? (true)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['true.Bool]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
NOT UNSAT: 'true.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: 'false.Bool ?= 'true.Bool /\ 'true.Bool ?= 'isEmpty['&28:List]
"sub-action" step successors: 0
UNSAT: 'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&28:List]
"sub-action" step successors: 0
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  77
Notice: no syntactically usable instances of axiom migrate found for  78
Warning: goal  85  satisfaction unknown: conservatively retaining goal
Warning: goal  88  satisfaction unknown: conservatively retaining goal
Auto Results:
       [93    |  <{}~> &27:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))> 
    |||  true = isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List
    $ &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
       [94    |  <{((y =l(y $: first(x));)(x =l rest(x);))(while((! empty(x))){
    (y =l(y $: first(x));)(x =l rest(x);)})}~> &27:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |-> &29:List)*(z
    |->(&29:List $ &28:List)))>  |||  false = isEmpty(&28:List) =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "true = isEmpty (&28:List)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
UNSAT: ff
"sub-action" step successors: 0
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  93
Notice: no syntactically usable instances of axiom migrate found for  94
Warning: goal  100  satisfaction unknown: conservatively retaining goal
Auto Results:
       [103   |  <(((y =l(y $: first(x));)(x =l rest(x);))(while((! empty(x))){
    (y =l(y $: first(x));)(x =l rest(x);)}))~> &27:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |-> &29:List)*(z
    |->(&29:List $ &28:List)))>  |||  false = isEmpty(&28:List) =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 2 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  103
Warning: goal  106  satisfaction unknown: conservatively retaining goal
Auto Results:
       [109   |  <((y =l(y $: first(x));)(x =l rest(x);))~>((while((! empty(
    x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation)|((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |-> &29:List)*(z
    |->(&29:List $ &28:List)))>  |||  false = isEmpty(&28:List) =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "false = isEmpty (&28:List)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  109
Warning: goal  112  satisfaction unknown: conservatively retaining goal
Auto Results:
       [115   |  <(y =l(y $: first(x));)~>((x =l rest(x);)~>((while((! empty(
    x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation))|((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |-> &29:List)*(z
    |->(&29:List $ &28:List)))>  |||  false = isEmpty(&28:List) =>  <
    &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 1
Constraint: "false = isEmpty (&28:List) /\\ false = val? (y $: first (x))"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  115
Warning: goal  118  satisfaction unknown: conservatively retaining goal
Auto Results:
       [121   |  <(y $: first(x))~>((y =l[];)~>((x =l rest(x);)~>((while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation)))|((
    x |-> TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |->
    &29:List)*(z |->(&29:List $ &28:List)))>  |||  false = isEmpty(&28:List) =>
     < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&30:List)/\ &29:List $ &28:List = Y&31:List $ X&30:List]
Action consumed 1 goals and generated 1 goals
Command: auto .

"ax-action" step checked failure
"step-action" step successors: 2
Constraint: "false = isEmpty (&28:List) /\\ false = val? (y)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List) /\\ false = val? (first (x))"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  121
Warning: goal  125  satisfaction unknown: conservatively retaining goal
Warning: goal  126  satisfaction unknown: conservatively retaining goal
Auto Results:
       [131   |  < y ~>(([]$: first(x))~>((y =l[];)~>((x =l rest(x);)~>((while(
    (! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  false =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
       [132   |  < first(x)~>((y $:[])~>((y =l[];)~>((x =l rest(x);)~>((while((
    ! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  false =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
Action consumed 1 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&28:List) /\\ false = val? (x)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  131
Notice: no syntactically usable instances of axiom migrate found for  132
Warning: goal  137  satisfaction unknown: conservatively retaining goal
Warning: goal  138  satisfaction unknown: conservatively retaining goal
Auto Results:
       [143   |  < &28:List ~>(([]$: first(x))~>((y =l[];)~>((x =l rest(x);)~>(
    (while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &28:List)*(z |->(&28:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&28:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &28:List $ &29:List =
    Y&31:List $ X&30:List]
       [144   |  < x ~>(first([])~>((y $:[])~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation)))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &28:List)*(y |-> &29:List)*(z |->(&29:List $ &28:List)))>  |||  false =
    isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &28:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &28:List =
    Y&31:List $ X&30:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&29:List)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  143
Notice: no syntactically usable instances of axiom migrate found for  144
Warning: goal  149  satisfaction unknown: conservatively retaining goal
Warning: goal  150  satisfaction unknown: conservatively retaining goal
Auto Results:
       [155   |  <(&27:List $: first(x))~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation)))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &27:List)*(z |->(&27:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&27:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &27:List $ &29:List =
    Y&31:List $ X&30:List]
       [156   |  < &29:List ~>(first([])~>((y $:[])~>((y =l[];)~>((x =l rest(
    x);)~>((while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation)))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &28:List)*(z |->(&28:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&28:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &28:List $ &29:List =
    Y&31:List $ X&30:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 1
Constraint: "false = isEmpty (&29:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "false = isEmpty (&29:List) /\\ false = val? (first (x))"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&27:List)"
"simp-action" step successors: 1
UNSAT: 'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&29:List]
"sub-action" step successors: 0
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  155
Notice: no syntactically usable instances of axiom migrate found for  156
Warning: goal  163  satisfaction unknown: conservatively retaining goal
Warning: goal  164  satisfaction unknown: conservatively retaining goal
Auto Results:
       [169   |  < first(x)~>((&27:List $:[])~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &27:List)*(z |->(&27:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&27:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &27:List $ &29:List =
    Y&31:List $ X&30:List]
       [170   |  < first(&27:List)~>((y $:[])~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &27:List)*(y |-> &29:List)*(z |->(&29:List $ &27:List)))>  |||  false =
    isEmpty(&27:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&29:List $
    &27:List)))>  |||  true = isEmpty(X&30:List)/\ &29:List $ &27:List =
    Y&31:List $ X&30:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 2
Constraint: "false = isEmpty (&29:List) /\\ false = val? (x)"
"simp-action" step successors: 1
Constraint: "false = isEmpty (&27:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: 'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&27:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  169
Notice: no syntactically usable instances of axiom migrate found for  170
Warning: goal  176  satisfaction unknown: conservatively retaining goal
Warning: goal  178  satisfaction unknown: conservatively retaining goal
Auto Results:
       [183   |  < x ~>(first([])~>((&27:List $:[])~>((y =l[];)~>((x =l rest(
    x);)~>((while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation)))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &27:List)*(z |->(&27:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&27:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &27:List $ &29:List =
    Y&31:List $ X&30:List]
       [184   |  < &30:Nat ~>((y $:[])~>((y =l[];)~>((x =l rest(x);)~>((while((
    ! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &27:List)*(y |-> &29:List)*(z |->(&29:List $ &27:List)))>  |||  &30:Nat =
    head(&27:List)/\ false = isEmpty(&27:List) =>  < &28:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&29:List $ &27:List)))>  |||  true = isEmpty(X&31:List)/\ &29:List $
    &27:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "&27:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&27:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  183
Notice: no syntactically usable instances of axiom migrate found for  184
Warning: goal  189  satisfaction unknown: conservatively retaining goal
Warning: goal  190  satisfaction unknown: conservatively retaining goal
Auto Results:
       [195   |  < &29:List ~>(first([])~>((&28:List $:[])~>((y =l[];)~>((x =l
    rest(x);)~>((while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &27:Continuation)))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &28:List)*(z |->(&28:List $ &29:List)))>  |||  false =
    isEmpty(&29:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&28:List $
    &29:List)))>  |||  true = isEmpty(X&30:List)/\ &28:List $ &29:List =
    Y&31:List $ X&30:List]
       [196   |  <(y $: &27:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &28:Continuation)))|((
    x |-> TList)*(y |-> TList)*(z |-> TList))&((x |-> &29:List)*(y |->
    &30:List)*(z |->(&30:List $ &29:List)))>  |||  &27:Nat = head(&29:List)/\
    false = isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&30:List
    $ &29:List)))>  |||  true = isEmpty(X&31:List)/\ &30:List $ &29:List =
    Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 2
Constraint: "false = isEmpty (&27:List)"
"simp-action" step successors: 1
Constraint: "&27:Nat = head (&29:List) /\\ false = isEmpty (&29:List) /\\ false = val? (&27:Nat)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:Nat]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&27:Nat = head (&29:List) /\\ false = isEmpty (&29:List) /\\ false = val? (y)"
"simp-action" step successors: 1
NOT UNSAT: 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: '&27:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&29:List]
"sub-action" step successors: 0
NOT UNSAT: '&27:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  195
Notice: no syntactically usable instances of axiom migrate found for  196
Warning: goal  202  satisfaction unknown: conservatively retaining goal
Warning: goal  204  satisfaction unknown: conservatively retaining goal
Auto Results:
       [209   |  < first(&27:List)~>((&28:List $:[])~>((y =l[];)~>((x =l rest(
    x);)~>((while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &27:List)*(y |-> &28:List)*(z |->(&28:List $ &27:List)))>  |||  false =
    isEmpty(&27:List) =>  < &29:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&30:List)*(y |-> Y&31:List)*(z |->(&28:List $
    &27:List)))>  |||  true = isEmpty(X&30:List)/\ &28:List $ &27:List =
    Y&31:List $ X&30:List]
       [210   |  < y ~>(([]$: &27:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while((
    ! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &29:List)*(y |-> &30:List)*(z |->(&30:List $ &29:List)))>  |||  &27:Nat =
    head(&29:List)/\ false = isEmpty(&29:List) =>  < &28:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&30:List $ &29:List)))>  |||  true = isEmpty(X&31:List)/\ &30:List $
    &29:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 1
Constraint: "false = isEmpty (&27:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
Constraint: "&27:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
UNSAT: 'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&27:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&27:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  209
Notice: no syntactically usable instances of axiom migrate found for  210
Warning: goal  217  satisfaction unknown: conservatively retaining goal
Warning: goal  218  satisfaction unknown: conservatively retaining goal
Auto Results:
       [223   |  < &30:Nat ~>((&28:List $:[])~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &27:List)*(y |-> &28:List)*(z |->(&28:List $ &27:List)))>  |||  &30:Nat =
    head(&27:List)/\ false = isEmpty(&27:List) =>  < &29:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&28:List $ &27:List)))>  |||  true = isEmpty(X&31:List)/\ &28:List $
    &27:List = Y&32:List $ X&31:List]
       [224   |  < &29:List ~>(([]$: &27:Nat)~>((y =l[];)~>((x =l rest(x);)~>((
    while((! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &28:Continuation))))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &30:List)*(y |-> &29:List)*(z |->(&29:List $ &30:List)))>  |||  &27:Nat =
    head(&30:List)/\ false = isEmpty(&30:List) =>  < &28:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&29:List $ &30:List)))>  |||  true = isEmpty(X&31:List)/\ &29:List $
    &30:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&27:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
NOT UNSAT: '&27:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  223
Notice: no syntactically usable instances of axiom migrate found for  224
Warning: goal  229  satisfaction unknown: conservatively retaining goal
Warning: goal  230  satisfaction unknown: conservatively retaining goal
Auto Results:
       [235   |  <(&28:List $: &27:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while(
    (! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation)))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &30:List)*(y |-> &28:List)*(z |->(&28:List $ &30:List)))>  |||  &27:Nat =
    head(&30:List)/\ false = isEmpty(&30:List) =>  < &29:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&28:List $ &30:List)))>  |||  true = isEmpty(X&31:List)/\ &28:List $
    &30:List = Y&32:List $ X&31:List]
       [236   |  <(&27:List $: &28:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while(
    (! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation)))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &30:List)*(y |-> &27:List)*(z |->(&27:List $ &30:List)))>  |||  &28:Nat =
    head(&30:List)/\ false = isEmpty(&30:List) =>  < &29:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&27:List $ &30:List)))>  |||  true = isEmpty(X&31:List)/\ &27:List $
    &30:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 3
"step-action" step successors: 3
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ false = val? (&28:Nat)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&28:Nat]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ false = val? (&28:Nat)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&28:Nat]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&28:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&30:List]
"sub-action" step successors: 0
UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&30:List]
"sub-action" step successors: 0
NOT UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&30:List]
"sub-action" step successors: 0
UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&30:List]
"sub-action" step successors: 0
NOT UNSAT: '&28:Nat ?= 'head['&30:List] /\ 'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  235
Notice: no syntactically usable instances of axiom migrate found for  236
Warning: goal  247  satisfaction unknown: conservatively retaining goal
Warning: goal  250  satisfaction unknown: conservatively retaining goal
Auto Results:
       [255   |  <(&27:List $ &28:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while((
    ! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation)))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &30:List)*(y |-> &27:List)*(z |->(&27:List $ &30:List)))>  |||  &28:Nat =
    head(&30:List)/\ false = isEmpty(&30:List) =>  < &29:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&27:List $ &30:List)))>  |||  true = isEmpty(X&31:List)/\ &27:List $
    &30:List = Y&32:List $ X&31:List]
       [256   |  <(&27:List $ &28:Nat)~>((y =l[];)~>((x =l rest(x);)~>((while((
    ! empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~>
    &29:Continuation)))|((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    &30:List)*(y |-> &27:List)*(z |->(&27:List $ &30:List)))>  |||  &28:Nat =
    head(&30:List)/\ false = isEmpty(&30:List) =>  < &29:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z
    |->(&27:List $ &30:List)))>  |||  true = isEmpty(X&31:List)/\ &27:List $
    &30:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List)"
"simp-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  255
Notice: no syntactically usable instances of axiom migrate found for  256
Warning: goal  261  satisfaction unknown: conservatively retaining goal
Warning: goal  262  satisfaction unknown: conservatively retaining goal
Auto Results:
       [267   |  <(y =l(&29:List $ &30:Nat);)~>((x =l rest(x);)~>((while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation))|((x
    |-> TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |->
    &29:List)*(z |->(&29:List $ &28:List)))>  |||  &30:Nat = head(&28:List)/\
    false = isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List
    $ &28:List)))>  |||  true = isEmpty(X&31:List)/\ &29:List $ &28:List =
    Y&32:List $ X&31:List]
       [268   |  <(y =l(&29:List $ &30:Nat);)~>((x =l rest(x);)~>((while((!
    empty(x))){(y =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation))|((x
    |-> TList)*(y |-> TList)*(z |-> TList))&((x |-> &28:List)*(y |->
    &29:List)*(z |->(&29:List $ &28:List)))>  |||  &30:Nat = head(&28:List)/\
    false = isEmpty(&28:List) =>  < &27:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List
    $ &28:List)))>  |||  true = isEmpty(X&31:List)/\ &29:List $ &28:List =
    Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 2
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (&29:List $ &30:Nat)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['_$_['&29:List,'&30:Nat]]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (&29:List $ &30:Nat)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['_$_['&29:List,'&30:Nat]]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&28:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&28:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  267
Notice: no syntactically usable instances of axiom migrate found for  268
Warning: goal  276  satisfaction unknown: conservatively retaining goal
Warning: goal  278  satisfaction unknown: conservatively retaining goal
Auto Results:
       [283   |  <(x =l rest(x);)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &27:Continuation)|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &29:List)*(y |->(&28:List $ &30:Nat))*(z |->(&28:List $
    &29:List)))>  |||  &30:Nat = head(&29:List)/\ false = isEmpty(&29:List) => 
    < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&31:List)*(y |-> Y&32:List)*(z |->(&28:List $ &29:List)))>  |||  true =
    isEmpty(X&31:List)/\ &28:List $ &29:List = Y&32:List $ X&31:List]
       [284   |  <(x =l rest(x);)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &27:Continuation)|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &29:List)*(y |->(&28:List $ &30:Nat))*(z |->(&28:List $
    &29:List)))>  |||  &30:Nat = head(&29:List)/\ false = isEmpty(&29:List) => 
    < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&31:List)*(y |-> Y&32:List)*(z |->(&28:List $ &29:List)))>  |||  true =
    isEmpty(X&31:List)/\ &28:List $ &29:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (rest (x))"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (rest (x))"
"simp-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  283
Notice: no syntactically usable instances of axiom migrate found for  284
Warning: goal  289  satisfaction unknown: conservatively retaining goal
Warning: goal  290  satisfaction unknown: conservatively retaining goal
Auto Results:
       [295   |  < rest(x)~>((x =l[];)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &27:Continuation))|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &28:List)*(y |->(&29:List $ &30:Nat))*(z |->(&29:List $
    &28:List)))>  |||  &30:Nat = head(&28:List)/\ false = isEmpty(&28:List) => 
    < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&31:List)/\ &29:List $ &28:List = Y&32:List $ X&31:List]
       [296   |  < rest(x)~>((x =l[];)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &27:Continuation))|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &28:List)*(y |->(&29:List $ &30:Nat))*(z |->(&29:List $
    &28:List)))>  |||  &30:Nat = head(&28:List)/\ false = isEmpty(&28:List) => 
    < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x |->
    X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &28:List)))>  |||  true =
    isEmpty(X&31:List)/\ &29:List $ &28:List = Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (x)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&28:List) /\\ false = isEmpty (&28:List) /\\ false = val? (x)"
"simp-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&28:List] /\ 'false.Bool ?= 'isEmpty['&28:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  295
Notice: no syntactically usable instances of axiom migrate found for  296
Warning: goal  301  satisfaction unknown: conservatively retaining goal
Warning: goal  302  satisfaction unknown: conservatively retaining goal
Auto Results:
       [307   |  < x ~>(rest([])~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &27:Continuation)))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &28:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &28:List)))>  |||  &30:Nat = head(&28:List)/\ false = isEmpty(
    &28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &28:List)))>
     |||  true = isEmpty(X&31:List)/\ &29:List $ &28:List = Y&32:List $
    X&31:List]
       [308   |  < x ~>(rest([])~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &27:Continuation)))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &28:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &28:List)))>  |||  &30:Nat = head(&28:List)/\ false = isEmpty(
    &28:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &28:List)))>
     |||  true = isEmpty(X&31:List)/\ &29:List $ &28:List = Y&32:List $
    X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&30:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&29:List] /\ 'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  307
Notice: no syntactically usable instances of axiom migrate found for  308
Warning: goal  313  satisfaction unknown: conservatively retaining goal
Warning: goal  314  satisfaction unknown: conservatively retaining goal
Auto Results:
       [319   |  < &29:List ~>(rest([])~>((x =l[];)~>((while((! empty(x))){(y
    =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation)))|((x |-> TList)*(
    y |-> TList)*(z |-> TList))&((x |-> &29:List)*(y |->(&28:List $ &30:Nat))*(
    z |->(&28:List $ &29:List)))>  |||  &30:Nat = head(&29:List)/\ false =
    isEmpty(&29:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&28:List $
    &29:List)))>  |||  true = isEmpty(X&31:List)/\ &28:List $ &29:List =
    Y&32:List $ X&31:List]
       [320   |  < &29:List ~>(rest([])~>((x =l[];)~>((while((! empty(x))){(y
    =l(y $: first(x));)(x =l rest(x);)})~> &27:Continuation)))|((x |-> TList)*(
    y |-> TList)*(z |-> TList))&((x |-> &29:List)*(y |->(&28:List $ &30:Nat))*(
    z |->(&28:List $ &29:List)))>  |||  &30:Nat = head(&29:List)/\ false =
    isEmpty(&29:List) =>  < &27:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&28:List $
    &29:List)))>  |||  true = isEmpty(X&31:List)/\ &28:List $ &29:List =
    Y&32:List $ X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  319
Notice: no syntactically usable instances of axiom migrate found for  320
Warning: goal  325  satisfaction unknown: conservatively retaining goal
Warning: goal  326  satisfaction unknown: conservatively retaining goal
Auto Results:
       [331   |  < rest(&27:List)~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &28:Continuation))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &27:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &27:List)))>  |||  &30:Nat = head(&27:List)/\ false = isEmpty(
    &27:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &27:List)))>
     |||  true = isEmpty(X&31:List)/\ &29:List $ &27:List = Y&32:List $
    X&31:List]
       [332   |  < rest(&27:List)~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &28:Continuation))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &27:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &27:List)))>  |||  &30:Nat = head(&27:List)/\ false = isEmpty(
    &27:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z |->
    TList))&((x |-> X&31:List)*(y |-> Y&32:List)*(z |->(&29:List $ &27:List)))>
     |||  true = isEmpty(X&31:List)/\ &29:List $ &27:List = Y&32:List $
    X&31:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 2
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ &31:List = tail (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ false = isEmpty (&27:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&30:Nat = head (&27:List) /\\ &31:List = tail (&27:List) /\\ false = isEmpty (&27:List)"
"simp-action" step successors: 1
UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&27:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ '&31:List ?= 'tail['&27:List] /\
    'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: '&30:Nat ?= 'head['&27:List] /\ 'false.Bool ?= 'true.Bool /\ 'false.Bool
    ?= 'isEmpty['&27:List]
"sub-action" step successors: 0
NOT UNSAT: '&30:Nat ?= 'head['&27:List] /\ '&31:List ?= 'tail['&27:List] /\
    'false.Bool ?= 'isEmpty['&27:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  331
Notice: no syntactically usable instances of axiom migrate found for  332
Warning: goal  340  satisfaction unknown: conservatively retaining goal
Warning: goal  342  satisfaction unknown: conservatively retaining goal
Auto Results:
       [347   |  < &31:List ~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &28:Continuation))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &27:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &27:List)))>  |||  &30:Nat = head(&27:List)/\ &31:List = tail(
    &27:List)/\ false = isEmpty(&27:List) =>  < &28:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z
    |->(&29:List $ &27:List)))>  |||  true = isEmpty(X&32:List)/\ &29:List $
    &27:List = Y&33:List $ X&32:List]
       [348   |  < &31:List ~>((x =l[];)~>((while((! empty(x))){(y =l(y $:
    first(x));)(x =l rest(x);)})~> &28:Continuation))|((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> &27:List)*(y |->(&29:List $ &30:Nat))*(z |->(
    &29:List $ &27:List)))>  |||  &30:Nat = head(&27:List)/\ &31:List = tail(
    &27:List)/\ false = isEmpty(&27:List) =>  < &28:Continuation |((x |->
    TList)*(y |-> TList)*(z |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z
    |->(&29:List $ &27:List)))>  |||  true = isEmpty(X&32:List)/\ &29:List $
    &27:List = Y&33:List $ X&32:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 1
"step-action" step successors: 1
Constraint: "&27:List = tail (&29:List) /\\ &31:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
Constraint: "&27:List = tail (&29:List) /\\ &31:Nat = head (&29:List) /\\ false = isEmpty (&29:List)"
"simp-action" step successors: 1
NOT UNSAT: '&27:List ?= 'tail['&29:List] /\ '&31:Nat ?= 'head['&29:List] /\
    'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
NOT UNSAT: '&27:List ?= 'tail['&29:List] /\ '&31:Nat ?= 'head['&29:List] /\
    'false.Bool ?= 'isEmpty['&29:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  347
Notice: no syntactically usable instances of axiom migrate found for  348
Warning: goal  353  satisfaction unknown: conservatively retaining goal
Warning: goal  354  satisfaction unknown: conservatively retaining goal
Auto Results:
       [359   |  <(x =l &27:List ;)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &28:Continuation)|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &29:List)*(y |->(&30:List $ &31:Nat))*(z |->(&30:List $
    &29:List)))>  |||  &27:List = tail(&29:List)/\ &31:Nat = head(&29:List)/\
    false = isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z |->(&30:List
    $ &29:List)))>  |||  true = isEmpty(X&32:List)/\ &30:List $ &29:List =
    Y&33:List $ X&32:List]
       [360   |  <(x =l &27:List ;)~>((while((! empty(x))){(y =l(y $: first(
    x));)(x =l rest(x);)})~> &28:Continuation)|((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> &29:List)*(y |->(&30:List $ &31:Nat))*(z |->(&30:List $
    &29:List)))>  |||  &27:List = tail(&29:List)/\ &31:Nat = head(&29:List)/\
    false = isEmpty(&29:List) =>  < &28:Continuation |((x |-> TList)*(y |->
    TList)*(z |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z |->(&30:List
    $ &29:List)))>  |||  true = isEmpty(X&32:List)/\ &30:List $ &29:List =
    Y&33:List $ X&32:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step checked failure
"ax-action" step checked failure
"step-action" step successors: 2
"step-action" step successors: 2
Constraint: "&27:List = tail (&29:List) /\\ &31:Nat = head (&29:List) /\\ false = isEmpty (&29:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&27:List = tail (&30:List) /\\ &31:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
Constraint: "&27:List = tail (&29:List) /\\ &31:Nat = head (&29:List) /\\ false = isEmpty (&29:List) /\\ false = val? (&27:List)"
Atom Reduced to Contradiction: 'false.Bool ?= 'val?['&27:List]
Atom Reduced to Contradiction: 'false.Bool ?= 'true.Bool
"simp-action" step successors: 1
Constraint: "&27:List = tail (&30:List) /\\ &31:Nat = head (&30:List) /\\ false = isEmpty (&30:List)"
"simp-action" step successors: 1
UNSAT: '&27:List ?= 'tail['&29:List] /\ '&31:Nat ?= 'head['&29:List] /\
    'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&29:List]
"sub-action" step successors: 0
NOT UNSAT: '&27:List ?= 'tail['&30:List] /\ '&31:Nat ?= 'head['&30:List] /\
    'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
UNSAT: '&27:List ?= 'tail['&29:List] /\ '&31:Nat ?= 'head['&29:List] /\
    'false.Bool ?= 'true.Bool /\ 'false.Bool ?= 'isEmpty['&29:List]
"sub-action" step successors: 0
NOT UNSAT: '&27:List ?= 'tail['&30:List] /\ '&31:Nat ?= 'head['&30:List] /\
    'false.Bool ?= 'isEmpty['&30:List]
CR Simplification Round Produced Unexpected Formula
CR Simplification Round Did NOT Reduce Implication
"sub-action" step successors: 1
Notice: no syntactically usable instances of axiom migrate found for  359
Notice: no syntactically usable instances of axiom migrate found for  360
Warning: goal  368  satisfaction unknown: conservatively retaining goal
Warning: goal  370  satisfaction unknown: conservatively retaining goal
Auto Results:
       [375   |  <(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})~> &28:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x
    |-> &27:List)*(y |->(&29:List $ &31:Nat))*(z |->(&29:List $ &30:List)))> 
    |||  &27:List = tail(&30:List)/\ &31:Nat = head(&30:List)/\ false =
    isEmpty(&30:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z |->(&29:List $
    &30:List)))>  |||  true = isEmpty(X&32:List)/\ &29:List $ &30:List =
    Y&33:List $ X&32:List]
       [376   |  <(while((! empty(x))){(y =l(y $: first(x));)(x =l rest(
    x);)})~> &28:Continuation |((x |-> TList)*(y |-> TList)*(z |-> TList))&((x
    |-> &27:List)*(y |->(&29:List $ &31:Nat))*(z |->(&29:List $ &30:List)))> 
    |||  &27:List = tail(&30:List)/\ &31:Nat = head(&30:List)/\ false =
    isEmpty(&30:List) =>  < &28:Continuation |((x |-> TList)*(y |-> TList)*(z
    |-> TList))&((x |-> X&32:List)*(y |-> Y&33:List)*(z |->(&29:List $
    &30:List)))>  |||  true = isEmpty(X&32:List)/\ &29:List $ &30:List =
    Y&33:List $ X&32:List]
Action consumed 2 goals and generated 2 goals
Command: auto .

"ax-action" step successors: 1
"ax-action" step successors: 1
Constraint: "&27:List = tail (&30:List) /\\ &31:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ true = isEmpty (X':List) /\\ &29:List $ &30:List = Y':List $ X':List"
"simp-action" step successors: 1
Constraint: "&27:List = tail (&30:List) /\\ &31:Nat = head (&30:List) /\\ false = isEmpty (&30:List) /\\ true = isEmpty (X':List) /\\ &29:List $ &30:List = Y':List $ X':List"
"simp-action" step successors: 1
"UNSAT" ERROR: not var-sat-opt(fmod 'fmod is
  nil
  sorts 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ; 'List ; 'Nat ;
    'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, none, disj-join(renameVars(('true.Bool != 'isEmpty['X':List] \/ '_$_[
    '&29:List,'&30:List] != '_$_['Y':List,'X':List]) << (
  '&27:List <- 'nil.List ; 
  '&29:List <- 'nil.List ; 
  '&30:List <- '#33:Nat ; 
  '&31:Nat <- '#33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '#33:Nat)
| ((
  '&27:List <- '#33:List ; 
  '&29:List <- 'nil.List ; 
  '&30:List <- '_$_['#32:Nat,'#33:List] ; 
  '&31:Nat <- '#32:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['#32:Nat,'#33:List]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['#33:List],'@S['#32:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['#32:Nat,'#33:List]]] =? 'X:@@@HeterogeneousList, 33, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['#33:List],'@S['#32:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['#32:Nat,'#33:List]]] =? 'X:@@@HeterogeneousList, 33, 0), empty))))
| ((
  '&27:List <- '%34:List ; 
  '&29:List <- '%32:List ; 
  '&30:List <- '_$_['%33:Nat,'%34:List] ; 
  '&31:Nat <- '%33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['%32:List,'%33:Nat,'%34:List]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['%34:List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat,'%34:List]]] =? 'X:@@@HeterogeneousList, 34, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['%34:List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat,'%34:List]]] =? 'X:@@@HeterogeneousList, 34, 0),
    empty))))
| ((
  '&27:List <- 'nil.List ; 
  '&29:List <- '%32:List ; 
  '&30:List <- '%33:Nat ; 
  '&31:Nat <- '%33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['%32:List,'%33:Nat]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['nil.List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat]]] =? 'X:@@@HeterogeneousList, 33, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['nil.List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat]]] =? 'X:@@@HeterogeneousList, 33, 0), empty)))))))
"sub-action" step successors: 0
"UNSAT" ERROR: not var-sat-opt(fmod 'fmod is
  nil
  sorts 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ; 'List ; 'Nat ;
    'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, none, disj-join(renameVars(('true.Bool != 'isEmpty['X':List] \/ '_$_[
    '&29:List,'&30:List] != '_$_['Y':List,'X':List]) << (
  '&27:List <- 'nil.List ; 
  '&29:List <- 'nil.List ; 
  '&30:List <- '#33:Nat ; 
  '&31:Nat <- '#33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '#33:Nat)
| ((
  '&27:List <- '#33:List ; 
  '&29:List <- 'nil.List ; 
  '&30:List <- '_$_['#32:Nat,'#33:List] ; 
  '&31:Nat <- '#32:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['#32:Nat,'#33:List]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['#33:List],'@S['#32:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['#32:Nat,'#33:List]]] =? 'X:@@@HeterogeneousList, 33, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['#33:List],'@S['#32:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['#32:Nat,'#33:List]]] =? 'X:@@@HeterogeneousList, 33, 0), empty))))
| ((
  '&27:List <- '%34:List ; 
  '&29:List <- '%32:List ; 
  '&30:List <- '_$_['%33:Nat,'%34:List] ; 
  '&31:Nat <- '%33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['%32:List,'%33:Nat,'%34:List]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['%34:List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat,'%34:List]]] =? 'X:@@@HeterogeneousList, 34, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['%34:List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat,'%34:List]]] =? 'X:@@@HeterogeneousList, 34, 0),
    empty))))
| ((
  '&27:List <- 'nil.List ; 
  '&29:List <- '%32:List ; 
  '&30:List <- '%33:Nat ; 
  '&31:Nat <- '%33:Nat ; 
  'X':List <- 'nil.List ; 
  'Y':List <- '_$_['%32:List,'%33:Nat]) << lift-sub(fmod 'fmod is
  nil
  sorts '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp
    ; 'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, p1($disjUnifiers(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['nil.List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat]]] =? 'X:@@@HeterogeneousList, 33, 0,
    metaDisjointUnify(fmod 'fmod is
  nil
  sorts '@@@HeterogeneousList ; '@@AExp ; '@@BExp ; '@@Bool ; '@@Exp ; '@@Id ;
    '@@Ids ; '@@LExp ; '@@List ; '@@Nat ; '@@NzNat ; '@@Stmt ; '@@Value ;
    '@HeterogeneousList ; 'AExp ; 'BExp ; 'Bool ; 'Exp ; 'Id ; 'Ids ; 'LExp ;
    'List ; 'Nat ; 'NzNat ; 'Stmt ; 'Value .
  subsort '@@@HeterogeneousList < '@HeterogeneousList .
  subsort '@@AExp < '@@Exp .
  subsort '@@AExp < 'AExp .
  subsort '@@BExp < '@@Exp .
  subsort '@@BExp < 'BExp .
  subsort '@@Bool < '@@BExp .
  subsort '@@Bool < '@@Value .
  subsort '@@Bool < 'Bool .
  subsort '@@Exp < 'Exp .
  subsort '@@Id < '@@AExp .
  subsort '@@Id < '@@LExp .
  subsort '@@Id < 'Id .
  subsort '@@Ids < 'Ids .
  subsort '@@LExp < '@@Exp .
  subsort '@@LExp < 'LExp .
  subsort '@@List < '@@LExp .
  subsort '@@List < '@@Value .
  subsort '@@List < 'List .
  subsort '@@Nat < '@@AExp .
  subsort '@@Nat < '@@List .
  subsort '@@Nat < '@@Value .
  subsort '@@Nat < 'Nat .
  subsort '@@NzNat < '@@Nat .
  subsort '@@NzNat < 'NzNat .
  subsort '@@Stmt < 'Stmt .
  subsort '@@Value < '@@Exp .
  subsort '@@Value < 'Value .
  subsort 'AExp < 'Exp .
  subsort 'BExp < 'Exp .
  subsort 'Bool < 'BExp .
  subsort 'Bool < 'Value .
  subsort 'Id < 'AExp .
  subsort 'Id < 'LExp .
  subsort 'LExp < 'Exp .
  subsort 'List < 'LExp .
  subsort 'List < 'Value .
  subsort 'Nat < 'AExp .
  subsort 'Nat < 'List .
  subsort 'Nat < 'Value .
  subsort 'NzNat < 'Nat .
  subsort 'Value < 'Exp .
  op '!_ : '@@BExp -> '@@BExp [ctor metadata("36")] .
  op '!_ : 'BExp -> 'BExp [ctor metadata("36")] .
  op '0 : nil -> '@@Nat [ctor metadata("2")] .
  op '0 : nil -> 'Nat [ctor metadata("2")] .
  op '1 : nil -> '@@NzNat [ctor metadata("3")] .
  op '1 : nil -> 'NzNat [ctor metadata("3")] .
  op '@S : '@@Exp -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Ids -> '@@@HeterogeneousList [ctor] .
  op '@S : '@@Stmt -> '@@@HeterogeneousList [ctor] .
  op '@S : 'Exp -> '@HeterogeneousList [ctor] .
  op '@S : 'Ids -> '@HeterogeneousList [ctor] .
  op '@S : 'Stmt -> '@HeterogeneousList [ctor] .
  op '_$:_ : '@@LExp '@@LExp -> '@@LExp [ctor metadata("39")] .
  op '_$:_ : 'LExp 'LExp -> 'LExp [ctor metadata("39")] .
  op '_$_ : '@@List '@@List -> '@@List [assoc ctor id('nil.List) metadata(
    "11")] .
  op '_$_ : 'List 'List -> 'List [assoc ctor id('nil.List) metadata("11")] .
  op '_&&:_ : '@@BExp '@@BExp -> '@@BExp [ctor metadata("38")] .
  op '_&&:_ : 'BExp 'BExp -> 'BExp [ctor metadata("38")] .
  op '_*:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("35")] .
  op '_*:_ : 'AExp 'AExp -> 'AExp [ctor metadata("35")] .
  op '_+:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("33")] .
  op '_+:_ : 'AExp 'AExp -> 'AExp [ctor metadata("33")] .
  op '_+_ : '@@Nat '@@Nat -> '@@Nat [assoc comm ctor id('0.Nat) metadata("4")]
    .
  op '_+_ : '@@NzNat '@@Nat -> '@@NzNat [assoc comm ctor id('0.Nat) metadata(
    "4")] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm ctor id('0.Nat) metadata("4")] .
  op '_-:_ : '@@AExp '@@AExp -> '@@AExp [ctor metadata("34")] .
  op '_-:_ : 'AExp 'AExp -> 'AExp [ctor metadata("34")] .
  op '_<:_ : '@@AExp '@@AExp -> '@@BExp [ctor metadata("37")] .
  op '_<:_ : 'AExp 'AExp -> 'BExp [ctor metadata("37")] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [metadata("6")] .
  op '_<_ : 'Nat 'Nat -> 'Bool [metadata("7")] .
  op '_=_; : '@@Id '@@AExp -> '@@Stmt [ctor metadata("31")] .
  op '_=_; : 'Id 'AExp -> 'Stmt [ctor metadata("31")] .
  op '_=l_; : '@@Id '@@LExp -> '@@Stmt [ctor metadata("32")] .
  op '_=l_; : 'Id 'LExp -> 'Stmt [ctor metadata("32")] .
  op '__ : '@@Stmt '@@Stmt -> '@@Stmt [ctor prec(42) gather('E 'e) metadata(
    "26")] .
  op '__ : 'Stmt 'Stmt -> 'Stmt [ctor prec(42) gather('E 'e) metadata("26")] .
  op '_`, : '@@Id -> '@@Id [ctor metadata("25")] .
  op '_`, : 'Id -> 'Id [ctor metadata("25")] .
  op '_monus_ : 'Nat 'Nat -> 'Nat [metadata("5")] .
  op '_|_ : '@@@HeterogeneousList '@@@HeterogeneousList ->
    '@@@HeterogeneousList [assoc ctor] .
  op '_|_ : '@HeterogeneousList '@HeterogeneousList -> '@HeterogeneousList [
    assoc ctor] .
  op '`{_`} : '@@Stmt -> '@@Stmt [ctor metadata("29")] .
  op '`{_`} : 'Stmt -> 'Stmt [ctor metadata("29")] .
  op '`{`} : nil -> '@@Stmt [ctor metadata("30")] .
  op '`{`} : nil -> 'Stmt [ctor metadata("30")] .
  op 'a : nil -> '@@Id [ctor metadata("16")] .
  op 'a : nil -> 'Id [ctor metadata("16")] .
  op 'b : nil -> '@@Id [ctor metadata("17")] .
  op 'b : nil -> 'Id [ctor metadata("17")] .
  op 'c : nil -> '@@Id [ctor metadata("18")] .
  op 'c : nil -> 'Id [ctor metadata("18")] .
  op 'empty`(_`) : '@@LExp -> '@@BExp [ctor metadata("42")] .
  op 'empty`(_`) : 'LExp -> 'BExp [ctor metadata("42")] .
  op 'false : nil -> '@@Bool [ctor metadata("1")] .
  op 'false : nil -> 'Bool [ctor metadata("1")] .
  op 'first`(_`) : '@@LExp -> '@@LExp [ctor metadata("40")] .
  op 'first`(_`) : 'LExp -> 'LExp [ctor metadata("40")] .
  op 'head : 'List -> 'Nat [metadata("13")] .
  op 'i : nil -> '@@Id [ctor metadata("19")] .
  op 'i : nil -> 'Id [ctor metadata("19")] .
  op 'if`(_`)_else_ : '@@BExp '@@Stmt '@@Stmt -> '@@Stmt [ctor metadata("27")]
    .
  op 'if`(_`)_else_ : 'BExp 'Stmt 'Stmt -> 'Stmt [ctor metadata("27")] .
  op 'isEmpty : 'List -> 'Bool [metadata("15")] .
  op 'j : nil -> '@@Id [ctor metadata("20")] .
  op 'j : nil -> 'Id [ctor metadata("20")] .
  op 'k : nil -> '@@Id [ctor metadata("21")] .
  op 'k : nil -> 'Id [ctor metadata("21")] .
  op 'nil : nil -> '@@List [ctor metadata("10")] .
  op 'nil : nil -> 'List [ctor metadata("10")] .
  op 'rest`(_`) : '@@LExp -> '@@LExp [ctor metadata("41")] .
  op 'rest`(_`) : 'LExp -> 'LExp [ctor metadata("41")] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm metadata("8")] .
  op 'singleton : '@@@HeterogeneousList -> '@@@HeterogeneousList [ctor] .
  op 'singleton : '@HeterogeneousList -> '@HeterogeneousList [ctor] .
  op 'tail : 'List -> 'List [metadata("14")] .
  op 'true : nil -> '@@Bool [ctor metadata("0")] .
  op 'true : nil -> 'Bool [ctor metadata("0")] .
  op 'val? : 'Exp -> 'Bool [metadata("43")] .
  op 'while`(_`)_ : '@@BExp '@@Stmt -> '@@Stmt [ctor metadata("28")] .
  op 'while`(_`)_ : 'BExp 'Stmt -> 'Stmt [ctor metadata("28")] .
  op 'x : nil -> '@@Id [ctor metadata("22")] .
  op 'x : nil -> 'Id [ctor metadata("22")] .
  op 'y : nil -> '@@Id [ctor metadata("23")] .
  op 'y : nil -> 'Id [ctor metadata("23")] .
  op 'z : nil -> '@@Id [ctor metadata("24")] .
  op 'z : nil -> 'Id [ctor metadata("24")] .
  none
  eq '_$_['head['L:List],'tail['L:List]] = 'L:List [none] .
  eq '_<=_['N:Nat,'_+_['N:Nat,'M:Nat]] = 'true.Bool [variant] .
  eq '_<=_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'false.Bool [variant] .
  eq '_<_['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'true.Bool [variant] .
  eq '_<_['_+_['N:Nat,'M:Nat],'N:Nat] = 'false.Bool [variant] .
  eq '_monus_['N:Nat,'_+_['N:Nat,'M:Nat]] = '0.Nat [variant] .
  eq '_monus_['_+_['N:Nat,'Z:NzNat],'N:Nat] = 'Z:NzNat [variant] .
  eq 'head['_$_['N:Nat,'L:List]] = 'N:Nat [variant] .
  eq 'isEmpty['nil.List] = 'true.Bool [variant] .
  eq 'isEmpty['_$_['N:Nat,'L:List]] = 'false.Bool [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'M:Nat]] = 'M:Nat [variant] .
  eq 'sd['N:Nat,'_+_['N:Nat,'Z:NzNat]] = 'Z:NzNat [variant] .
  eq 'tail['nil.List] = 'nil.List [variant] .
  eq 'tail['_$_['N:Nat,'L:List]] = 'L:List [variant] .
  eq 'val?['Q:Id] = 'false.Bool [variant] .
  eq 'val?['V:Value] = 'true.Bool [variant] .
  eq 'val?['!_['B:BExp]] = 'false.Bool [variant] .
  eq 'val?['_$:_['L:LExp,'L':LExp]] = 'false.Bool [variant] .
  eq 'val?['_&&:_['B:BExp,'B':BExp]] = 'false.Bool [variant] .
  eq 'val?['_*:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_+:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_-:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['_<:_['A:AExp,'A':AExp]] = 'false.Bool [variant] .
  eq 'val?['empty`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['first`(_`)['L:LExp]] = 'false.Bool [variant] .
  eq 'val?['rest`(_`)['L:LExp]] = 'false.Bool [variant] .
endfm, '_|_['@S['nil.List],'@S['%33:Nat],'@S['false.Bool],'@S['true.Bool],'@S[
    '_$_['%32:List,'%33:Nat]]] =? 'X:@@@HeterogeneousList, 33, 0), empty)))))))
"sub-action" step successors: 0
Proof Completed.
Action consumed 2 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Proof Completed.
Action consumed 0 goals and generated 0 goals
Command: auto .

Bye.
